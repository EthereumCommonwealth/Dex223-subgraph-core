// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class ERC20WrapperCreated extends ethereum.Event {
  get params(): ERC20WrapperCreated__Params {
    return new ERC20WrapperCreated__Params(this);
  }
}

export class ERC20WrapperCreated__Params {
  _event: ERC20WrapperCreated;

  constructor(event: ERC20WrapperCreated) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _ERC20Wrapper(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ERC223WrapperCreated extends ethereum.Event {
  get params(): ERC223WrapperCreated__Params {
    return new ERC223WrapperCreated__Params(this);
  }
}

export class ERC223WrapperCreated__Params {
  _event: ERC223WrapperCreated;

  constructor(event: ERC223WrapperCreated) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _ERC223Wrapper(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TokenConverter extends ethereum.SmartContract {
  static bind(address: Address): TokenConverter {
    return new TokenConverter("TokenConverter", address);
  }

  convertERC20(_token: Address, _amount: BigInt): boolean {
    let result = super.call(
      "convertERC20",
      "convertERC20(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_convertERC20(
    _token: Address,
    _amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "convertERC20",
      "convertERC20(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  createERC20Wrapper(_token: Address): Address {
    let result = super.call(
      "createERC20Wrapper",
      "createERC20Wrapper(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_createERC20Wrapper(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "createERC20Wrapper",
      "createERC20Wrapper(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  createERC223Wrapper(_token: Address): Address {
    let result = super.call(
      "createERC223Wrapper",
      "createERC223Wrapper(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_createERC223Wrapper(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "createERC223Wrapper",
      "createERC223Wrapper(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenReceived(_from: Address, _value: BigInt, param2: Bytes): Bytes {
    let result = super.call(
      "tokenReceived",
      "tokenReceived(address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromBytes(param2),
      ],
    );

    return result[0].toBytes();
  }

  try_tokenReceived(
    _from: Address,
    _value: BigInt,
    param2: Bytes,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "tokenReceived",
      "tokenReceived(address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromBytes(param2),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  unwrapERC20toERC223(_ERC20token: Address, _amount: BigInt): boolean {
    let result = super.call(
      "unwrapERC20toERC223",
      "unwrapERC20toERC223(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_ERC20token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_unwrapERC20toERC223(
    _ERC20token: Address,
    _amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "unwrapERC20toERC223",
      "unwrapERC20toERC223(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_ERC20token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  wrapERC20toERC223(_ERC20token: Address, _amount: BigInt): boolean {
    let result = super.call(
      "wrapERC20toERC223",
      "wrapERC20toERC223(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_ERC20token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_wrapERC20toERC223(
    _ERC20token: Address,
    _amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "wrapERC20toERC223",
      "wrapERC20toERC223(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_ERC20token),
        ethereum.Value.fromUnsignedBigInt(_amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  erc20Origins(param0: Address): Address {
    let result = super.call("erc20Origins", "erc20Origins(address):(address)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toAddress();
  }

  try_erc20Origins(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "erc20Origins",
      "erc20Origins(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  erc20Supply(param0: Address): BigInt {
    let result = super.call("erc20Supply", "erc20Supply(address):(uint256)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBigInt();
  }

  try_erc20Supply(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "erc20Supply",
      "erc20Supply(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  erc20Wrappers(param0: Address): Address {
    let result = super.call(
      "erc20Wrappers",
      "erc20Wrappers(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toAddress();
  }

  try_erc20Wrappers(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "erc20Wrappers",
      "erc20Wrappers(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  erc223Origins(param0: Address): Address {
    let result = super.call(
      "erc223Origins",
      "erc223Origins(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toAddress();
  }

  try_erc223Origins(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "erc223Origins",
      "erc223Origins(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  erc223Wrappers(param0: Address): Address {
    let result = super.call(
      "erc223Wrappers",
      "erc223Wrappers(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toAddress();
  }

  try_erc223Wrappers(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "erc223Wrappers",
      "erc223Wrappers(address):(address)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getERC20OriginFor(_token: Address): Address {
    let result = super.call(
      "getERC20OriginFor",
      "getERC20OriginFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_getERC20OriginFor(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getERC20OriginFor",
      "getERC20OriginFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getERC20WrapperFor(_token: Address): Address {
    let result = super.call(
      "getERC20WrapperFor",
      "getERC20WrapperFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_getERC20WrapperFor(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getERC20WrapperFor",
      "getERC20WrapperFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getERC223OriginFor(_token: Address): Address {
    let result = super.call(
      "getERC223OriginFor",
      "getERC223OriginFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_getERC223OriginFor(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getERC223OriginFor",
      "getERC223OriginFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getERC223WrapperFor(_token: Address): Address {
    let result = super.call(
      "getERC223WrapperFor",
      "getERC223WrapperFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toAddress();
  }

  try_getERC223WrapperFor(_token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getERC223WrapperFor",
      "getERC223WrapperFor(address):(address)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isWrapper(_token: Address): boolean {
    let result = super.call("isWrapper", "isWrapper(address):(bool)", [
      ethereum.Value.fromAddress(_token),
    ]);

    return result[0].toBoolean();
  }

  try_isWrapper(_token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isWrapper", "isWrapper(address):(bool)", [
      ethereum.Value.fromAddress(_token),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  predictWrapperAddress(_token: Address, _isERC20: boolean): Address {
    let result = super.call(
      "predictWrapperAddress",
      "predictWrapperAddress(address,bool):(address)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromBoolean(_isERC20),
      ],
    );

    return result[0].toAddress();
  }

  try_predictWrapperAddress(
    _token: Address,
    _isERC20: boolean,
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "predictWrapperAddress",
      "predictWrapperAddress(address,bool):(address)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromBoolean(_isERC20),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConvertERC20Call extends ethereum.Call {
  get inputs(): ConvertERC20Call__Inputs {
    return new ConvertERC20Call__Inputs(this);
  }

  get outputs(): ConvertERC20Call__Outputs {
    return new ConvertERC20Call__Outputs(this);
  }
}

export class ConvertERC20Call__Inputs {
  _call: ConvertERC20Call;

  constructor(call: ConvertERC20Call) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConvertERC20Call__Outputs {
  _call: ConvertERC20Call;

  constructor(call: ConvertERC20Call) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class CreateERC20WrapperCall extends ethereum.Call {
  get inputs(): CreateERC20WrapperCall__Inputs {
    return new CreateERC20WrapperCall__Inputs(this);
  }

  get outputs(): CreateERC20WrapperCall__Outputs {
    return new CreateERC20WrapperCall__Outputs(this);
  }
}

export class CreateERC20WrapperCall__Inputs {
  _call: CreateERC20WrapperCall;

  constructor(call: CreateERC20WrapperCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class CreateERC20WrapperCall__Outputs {
  _call: CreateERC20WrapperCall;

  constructor(call: CreateERC20WrapperCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class CreateERC223WrapperCall extends ethereum.Call {
  get inputs(): CreateERC223WrapperCall__Inputs {
    return new CreateERC223WrapperCall__Inputs(this);
  }

  get outputs(): CreateERC223WrapperCall__Outputs {
    return new CreateERC223WrapperCall__Outputs(this);
  }
}

export class CreateERC223WrapperCall__Inputs {
  _call: CreateERC223WrapperCall;

  constructor(call: CreateERC223WrapperCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class CreateERC223WrapperCall__Outputs {
  _call: CreateERC223WrapperCall;

  constructor(call: CreateERC223WrapperCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class ExtractStuckERC20Call extends ethereum.Call {
  get inputs(): ExtractStuckERC20Call__Inputs {
    return new ExtractStuckERC20Call__Inputs(this);
  }

  get outputs(): ExtractStuckERC20Call__Outputs {
    return new ExtractStuckERC20Call__Outputs(this);
  }
}

export class ExtractStuckERC20Call__Inputs {
  _call: ExtractStuckERC20Call;

  constructor(call: ExtractStuckERC20Call) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ExtractStuckERC20Call__Outputs {
  _call: ExtractStuckERC20Call;

  constructor(call: ExtractStuckERC20Call) {
    this._call = call;
  }
}

export class TokenReceivedCall extends ethereum.Call {
  get inputs(): TokenReceivedCall__Inputs {
    return new TokenReceivedCall__Inputs(this);
  }

  get outputs(): TokenReceivedCall__Outputs {
    return new TokenReceivedCall__Outputs(this);
  }
}

export class TokenReceivedCall__Inputs {
  _call: TokenReceivedCall;

  constructor(call: TokenReceivedCall) {
    this._call = call;
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get value2(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class TokenReceivedCall__Outputs {
  _call: TokenReceivedCall;

  constructor(call: TokenReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class UnwrapERC20toERC223Call extends ethereum.Call {
  get inputs(): UnwrapERC20toERC223Call__Inputs {
    return new UnwrapERC20toERC223Call__Inputs(this);
  }

  get outputs(): UnwrapERC20toERC223Call__Outputs {
    return new UnwrapERC20toERC223Call__Outputs(this);
  }
}

export class UnwrapERC20toERC223Call__Inputs {
  _call: UnwrapERC20toERC223Call;

  constructor(call: UnwrapERC20toERC223Call) {
    this._call = call;
  }

  get _ERC20token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UnwrapERC20toERC223Call__Outputs {
  _call: UnwrapERC20toERC223Call;

  constructor(call: UnwrapERC20toERC223Call) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class WrapERC20toERC223Call extends ethereum.Call {
  get inputs(): WrapERC20toERC223Call__Inputs {
    return new WrapERC20toERC223Call__Inputs(this);
  }

  get outputs(): WrapERC20toERC223Call__Outputs {
    return new WrapERC20toERC223Call__Outputs(this);
  }
}

export class WrapERC20toERC223Call__Inputs {
  _call: WrapERC20toERC223Call;

  constructor(call: WrapERC20toERC223Call) {
    this._call = call;
  }

  get _ERC20token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WrapERC20toERC223Call__Outputs {
  _call: WrapERC20toERC223Call;

  constructor(call: WrapERC20toERC223Call) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
